// Pooled Mixer with Sub Contract Data

// Testnet Version Features Destroyable Contracts; Mainnet does not.

Contract SpeedMixer (
    owner: Address,		                        // Owner of Contract (Mix Dev)
    mut mixfee: U256,                           // ALPH on testnet
    mixtoken: ByteVec,
    datacontract: ByteVec,                      // Mix-Retrieve Data Contract
    mut datacontracts: U256,
    // Fees Collected
    mut feescollected: U256,                    // Total Mix Collected
    mut alphstoragefee: U256,
    mut alphincontract: U256
) {
    event Data(data: ByteVec)   // No addresses for maximum privacy just global stats

    enum ErrorCodes {
        InvalidCaller = 0
        InvalidAlph = 1
    }

    pub fn getOwner() -> Address {
        return owner
    }

    pub fn getMixFee() -> U256 {
        return mixfee
    }

    pub fn getMixToken() -> ByteVec {
        return mixtoken
    }

    // check this function -> regarding adding users
    pub fn checkAvailable() -> U256 {
        for (let mut index = 0; index < datacontracts; index = index + 1) {

            let mixsubcontract = subContractId!(toByteVec!(index))
            let freeindex = MixData(mixsubcontract).getFirstFreeIndex()

            if (freeindex != 11) {
                return index
            }
        }
        return 11
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn createmixdata(key: ByteVec, amount: U256) -> () { // key is hash and is generated by us, not shared or stored

        let idealcontract = checkAvailable() 

        if (datacontracts != 0 && idealcontract != 11) {

            let mixsubcontract = subContractId!(toByteVec!(idealcontract))

            MixData(mixsubcontract).adduser(key, amount)

            transferToken!(callerAddress!(), selfAddress!(), ALPH, amount)
            transferToken!(callerAddress!(), selfAddress!(), getMixToken(), getMixFee())

        }
        else {

            assert!(alphincontract > 1000000000000000000, ErrorCodes.InvalidAlph)

            let nullbyte = toByteVec!(10)
	
	        let (encodeImmutableFields, encodeMutableFields) = MixData.encodeFields!([key, nullbyte, nullbyte, nullbyte, nullbyte, nullbyte, nullbyte, nullbyte, nullbyte, nullbyte], [amount, 0, 0, 0, 0, 0, 0, 0, 0, 0], selfAddress!()) // SecurityKey / Amount

            let newmixdata = copyCreateSubContract!{selfAddress!() -> ALPH: alphstoragefee}(
                toByteVec!(datacontracts),              // PATH -> this will need to be a u256
                datacontract,                           // DATACONTRACT
                encodeImmutableFields,                  // IMMUTABLE FIELDS
                encodeMutableFields                     // ENCODE MUTABLE FIELDS
            )

            transferToken!(callerAddress!(), selfAddress!(), ALPH, amount)                         // GET ASSETS -> CONTRACT
            transferToken!(callerAddress!(), selfAddress!(), getMixToken(), getMixFee())           // MIX FEE

            feescollected = feescollected + getMixFee()
            datacontracts = datacontracts + 1                                                      // Minimum is 1
            alphincontract = alphincontract - 1000000000000000000                                  // 1 ALPH

            emit Data(newmixdata)
        }
    }

    @using(preapprovedAssets = false, assetsInContract = true, updateFields = false, checkExternalCaller = false)
    pub fn getassets(amount: U256, key: ByteVec) -> () { // key is then used for sub contract path

        for (let mut index = 0; index < datacontracts; index = index + 1) {

            let mixsubcontract = subContractId!(toByteVec!(index)) // makes sense

            let ishashpresent = MixData(mixsubcontract).getIndex(key)

            if (ishashpresent != 11) {

                let editeddata = MixData(mixsubcontract).changeamount(key, amount)

                if (editeddata == true) {

                    transferToken!(selfAddress!(), callerAddress!(), ALPH, amount)

                }
            }
            
        }
    }

    @using(preapprovedAssets = false, assetsInContract = true, updateFields = false, checkExternalCaller = false)
    pub fn getallassets(key: ByteVec) -> () { // key is then used for sub contract path

        for (let mut index = 0; index < datacontracts; index = index + 1) {

            let mixsubcontract = subContractId!(toByteVec!(index)) // makes sense

            let ishashpresent = MixData(mixsubcontract).getIndex(key)

            if (ishashpresent != 11) {

                let alphamount = MixData(mixsubcontract).getAmount(key)

                let editeddata = MixData(mixsubcontract).changeamount(key, alphamount)

                if (editeddata == true) {

                    transferToken!(selfAddress!(), callerAddress!(), ALPH, alphamount)

                }
            }
            
        }
    }

    @using(preapprovedAssets = false, assetsInContract = true, updateFields = true, checkExternalCaller = true)
    pub fn collectfees() -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        transferToken!(selfAddress!(), getOwner(), getMixToken(), feescollected)

        feescollected = feescollected - feescollected
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = true)
    pub fn depositalph() -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        alphincontract = alphincontract + 1000000000000000000

        transferToken!(callerAddress!(), selfAddress!(), ALPH, 1 alph)
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn changefee(newfee: U256) -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        mixfee = newfee
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn lowerstoragefee(newfee: U256) -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        alphstoragefee = newfee

    }

    @using(preapprovedAssets = false, assetsInContract = true, updateFields = true, checkExternalCaller = true)
    pub fn removealph(amount: U256) -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        transferTokenFromSelf!(owner, ALPH, amount)

        alphincontract = alphincontract - amount

    }

    // upgradable on mainnet
    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn upgrade(newCode: ByteVec, newImmFieldsEncoded: ByteVec, newMutFieldsEncoded: ByteVec) -> () {

        checkCaller!(owner == callerAddress!(), ErrorCodes.InvalidCaller)

        migrateWithFields!(newCode, newImmFieldsEncoded, newMutFieldsEncoded)
    }
}
